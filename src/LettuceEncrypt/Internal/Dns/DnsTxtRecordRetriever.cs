// Copyright (c) Nate McMaster.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

// Generated by ChatGPT + Gemini 1121

using System.Net;
using System.Net.Sockets;
using System.Text;

namespace LettuceEncrypt.Internal.Dns;

internal static class DnsTxtRecordRetriever
{
    private const int DnsPort = 53;
    private const int DnsTimeout = 5000; // Timeout in milliseconds

    public static async Task<string[]> GetTxtRecords(string domain, IPAddress dnsServer,
        CancellationToken cancellationToken = default)
    {
        using var udpClient = new UdpClient();
        udpClient.Client.ReceiveTimeout = DnsTimeout;

        var query = BuildDnsQuery(domain);
        var serverEndpoint = new IPEndPoint(dnsServer, DnsPort);

        udpClient.Connect(serverEndpoint);

        // Send DNS query
        await udpClient.SendAsync(query, cancellationToken).ConfigureAwait(false);

        // Receive response
        var response = await udpClient.ReceiveAsync(cancellationToken).ConfigureAwait(false);

        // Parse response
        return ParseDnsResponse(response.Buffer);
    }

    private static byte[] BuildDnsQuery(string domain)
    {
        var random = new Random();
        var transactionId = new byte[2];
        random.NextBytes(transactionId);

        // DNS header: transaction ID (2 bytes) + flags (2 bytes) + questions (2 bytes) + answer/prereq/additional (6 bytes)
        var header = new byte[12];
        Array.Copy(transactionId, 0, header, 0, 2);
        header[2] = 1; // Recursion desired
        header[5] = 1; // One question

        // Question section
        var domainParts = domain.Split('.');
        var question = domainParts
            .Select(part => Encoding.ASCII.GetBytes(part).Prepend((byte)part.Length).ToArray())
            .SelectMany(bytes => bytes)
            .ToArray();

        var questionTypeAndClass = new byte[] { 0x00, 0x10, 0x00, 0x01 }; // TXT type (0x10) + IN class (0x01)
        var query = header.Concat(question).Append((byte)0x00).Concat(questionTypeAndClass).ToArray();

        return query;
    }

    internal static string[] ParseDnsResponse(byte[] response)
    {
        var txtRecords = new List<string>();

        // Basic response validation (at least a header)
        if (response.Length < 12)
        {
            return Array.Empty<string>();
        }

        // Header parsing
        var queryCount = (response[4] << 8) | response[5];    // QDCOUNT
        var answerCount = (response[6] << 8) | response[7];   // ANCOUNT
        var authorityCount = (response[8] << 8) | response[9]; // NSCOUNT
        var additionalCount = (response[10] << 8) | response[11]; // ARCOUNT

        // Skip the question section (we assume only one question for simplicity)
        var currentIndex = 12;
        for (var i = 0; i < queryCount; i++)
        {
            currentIndex = SkipName(response, currentIndex);
            currentIndex += 4; // QTYPE and QCLASS
        }

        // Parse answer records
        for (var i = 0; i < answerCount; i++)
        {
            currentIndex = SkipName(response, currentIndex); // Name

            var recordType = (response[currentIndex] << 8) | response[currentIndex + 1];
            currentIndex += 2;

            var recordClass = (response[currentIndex] << 8) | response[currentIndex + 1];
            currentIndex += 2;

            var ttl = (response[currentIndex] << 24) | (response[currentIndex + 1] << 16) | (response[currentIndex + 2] << 8) | response[currentIndex + 3];
            currentIndex += 4;

            var dataLength = (response[currentIndex] << 8) | response[currentIndex + 1];
            currentIndex += 2;

            // Process TXT records
            if (recordType == 16) // TXT record type
            {
                var dataStartIndex = currentIndex;
                while (dataStartIndex < currentIndex + dataLength)
                {
                    int stringLength = response[dataStartIndex];
                    dataStartIndex++;

                    var txtData = Encoding.ASCII.GetString(response, dataStartIndex, stringLength);
                    txtRecords.Add(txtData);
                    dataStartIndex += stringLength;
                }
            }

            currentIndex += dataLength; // Move to the next record
        }

        return txtRecords.ToArray();
    }

    // Helper function to skip domain names (handles pointer compression)
    private static int SkipName(byte[] response, int startIndex)
    {
        var currentIndex = startIndex;
        while (response[currentIndex] != 0)
        {
            if ((response[currentIndex] & 0xC0) == 0xC0) // Pointer
            {
                currentIndex += 2;
                return currentIndex;
            }
            else
            {
                currentIndex += response[currentIndex] + 1; // Move past label length and label
            }
        }
        return currentIndex + 1; // Skip null terminator
    }
}
